// 비교 연산자
const b1 = 2 & 3;

console.log (b1);

// 비교하는 비트가 모두 1이면 1을 반환합니다
// 2 0010
// 3 0011
// 2 0010

// 논리 연산자

const b2 = 2 | 3;
console.log(b2);

// 비교하는 비트 중에서 하나라도 1이면 1을 반환합니다 
// 2 0010 
// 3 0011
//   0011 = 3

// 배타 논리 연산자

const b3 = 5 ^ 3 ;
console.log(b3)

// 비교하는 두개의 비트가 같으면 0 을 다르면 1을 반환한다 
// 5 0101
// 3 0011
//   0110 = 6


// 부정 논리 연산자

const b4 = ~4;
console.log(b4);

// 0000 0100 4
// 1111 1011 -4 (비트 반전)

// 2의 보수: 이진수 1111 10111은 2의 보수 표현으로 -5를 나타냅니다  (부호 비트가 1이므로 음수입니다.)

// 왼쪽 시프트 연산자  
/* 지정한 수만큼 비트 전체를 왼쪽으로 이동한다
   몇칸 이동했는지에 따라 2의 제곱만큼 수가 곱해진다   */

const b5 = 4 << 2 ;
console.log(b5)

// 0000 0100 4
// 0000 1000 8 (1비트 이동)
// 0001 0000 16 (2비트 이동)


// 오른쪽 시프트 연산자  
/* 지정한 수만큼 비트 전체를 오른쪽으로 이동한다
   오른쪽에 있는 비트가 소멸되기 때문에 규칙성이 없다   */

   const b6 = 4 >> 2 ;
   console.log(b6)
   
   // 0000 0100 4
   //  0000 0010 8 (1비트 이동)
   //    00 0001 16 (2비트 이동)
   
   
// 부호 없는 오른쪽 시프트 연산자
// 지정한 수만큼 32비트 숫자의 모든 비트를 오른쪽으로 이동하며 빈 비트는 전부 0으로 체운다
// 양수에서는 부호있는 오른쪽 시프트와 동일하게 동작하지만 음수일 경우 다르다 
// -> 빈 비트를 0으로 채우며 음수의 2진 표현을 양수로 간주하기 때문이다

const b7 = 5 >>> 2;
const b8 = -5 >>> 2;

console.log(b7); // 1

// 0000000000000000000000000000000101
// 0000000000000000000000000000000001


comsole.log(b8); // 1073741822

// -0000000000000000000000000000000101 (= 111111111111111111111111111111111111010) -5
//  0011111111111111111111111111111110 1073741822 (2비트 이동)
